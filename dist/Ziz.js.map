{"version":3,"file":null,"sources":["../src/ziz.js","../src/parser/escapeSpecialChars.js","../src/parser/del.js","../src/parser/header.js","../src/parser/link.js","../src/parser/list.js","../src/parser/table.js","../src/parser/code.js","../src/parser/paragraph.js","../src/parser/blockquotes.js"],"sourcesContent":["import config from \"./ziz.config\";\nimport space from \"./parser/space\";\nimport escapeSpecialChars from \"./parser/escapeSpecialChars\";\nimport del from \"./parser/del\";\nimport header from \"./parser/header\";\nimport link from \"./parser/link\";\nimport list from \"./parser/list\";\nimport table from \"./parser/table\";\nimport code from \"./parser/code\";\nimport paragraph from \"./parser/paragraph\";\nimport blockquotes from \"./parser/blockquotes\";\n\nexport default function Ziz ( content ) {\n    content += \"\\r\\n\";\n    // content = space( content );\n    // TODO: delete space\n    content = escapeSpecialChars( content );\n    // TODO: fix this\n    content = header( content );\n    content = link( content );\n    // TODO: fixed table\n    content = table( content );\n    content = code( content );\n    content = list( content );\n    content = blockquotes ( content );\n    content = del( content );\n    content = paragraph( content );\n    return content;\n}\n","/**\n * escape special chars\n * @param  {[type]} content [description]\n * @return {[type]}         [description]\n */\nexport default ( content ) => {\n    content = content.replace( /</g, \"&lt;\" );\n    content = content.replace( />/g, \"&gt;\" );\n    // content = content.replace( /&/g, \"&amp;\" );\n    content = content.replace( /\"/g, \"&quot;\" );\n    content = content.replace( /'/g, \"&apos;\" );\n    content = content.replace( /\\\\/g, \"&bsol;\" );\n    content = content.replace( /\\//g, \"&sol;\" );\n    return content;\n};\n","/**\n * Deleted Text Element\n * @param  {[type]} content [description]\n * @return {[type]}         [description]\n */\nexport default ( content ) => {\n    let reg = /~~(?!~)(.*)?~~/m;\n    content = content.replace( reg, ( $0, $1, $2 ) => {\n        return \"<del>\" + $2 + \"</del>\";\n    });\n    return content;\n};\n","/**\n * header 1~6\n * @param  {[type]} content [description]\n * @return {[type]}         [description]\n */\nexport default ( content ) => {\n    let setextHeader1 = /^(.*)\\r?\\n(={5,})$/gm;                 // setext style header 1\n    let setextHeader2 = /^(.*)\\r?\\n(-{5,})$/gm;                 // setext style header 2\n\n    for ( let i = 6; i >= 1; i-- ) {\n        let atx = `^(#{${i}})([^#].*?)((#{1,})?$)`;          // atx header\n        let regex = new RegExp( atx, \"gm\" );\n        content = content.replace( regex, ( $0, $1, $2, index, str ) => {\n            // console.log($2)\n            return `<h${i}>${$2}</h${i}>`;\n        });\n    }\n    content = content.replace( setextHeader1, ( $0, $1, $2, index, str ) => {\n        return `<h1>${$1}</h1>`;\n    });\n    content = content.replace( setextHeader2, ( $0, $1, $2, index, str) => {\n        return `<h2>${$1}</h2>`;\n    });\n    return content;\n};\n","/**\n * link\n * @param  {[type]} content [description]\n * @return {[type]}         [description]\n */\nexport default ( content ) => {\n    // inline link\n    const inlineLinkRegex = /\\[([^\\[].*?)\\]\\((.*?)((?:\\u0020*)&quot;(.*?)&quot;)?\\)/gm;\n    content = content.replace( inlineLinkRegex, ( $0, $1, $2, $3, $4 ) => {\n        let text = $1;\n        let url = $2;\n        let title = $4;\n        return `<a href=\"${ url }\" title=\"${ title }\">${ text }</a>`;\n    });\n    // TODO: reference style links\n    // console.log( content )\n    return content;\n}\n","/**\n * list\n * @param  {[type]} content [description]\n * @return {[type]}         [description]\n */\nexport default ( content ) => {\n    const ulStart = \"<ul>\";\n    const ulEnd = \"</ul>\";\n    const olStart = \"<ol>\";\n    const olEnd = \"</ol>\";\n    const isUnorderedList = /(([\\*|\\+|\\-])(\\u0020)+)(.*?)$/;\n    const isOrderedList = /((^[\\d]\\.)(\\u0020)+)(.*?)$/;\n    let arr = content.split( /\\n/ );\n\n    // unordered list\n    let isFirstListItem = true;\n    let length = arr.length;\n    // console.log(arr);\n    // console.log(isUnorderedList.test( arr[1] ));\n\n    let newArr = arr.map( ( item, index, arr ) => {\n        if ( isUnorderedList.test( item ) ) {\n            item = item.replace( isUnorderedList, ( $0, $1, $2, $3, $4, index, str ) => {\n                return \"<li>\" + $4 + \"</li>\";\n            });\n            if ( isFirstListItem ) {\n                item = ulStart + item;\n            }\n            if ( index === ( length - 1 ) || !isUnorderedList.test( arr[index + 1] ) ) {\n                item = item + ulEnd;\n            }\n            isFirstListItem = false;\n        } else {\n            isFirstListItem = true;\n        }\n        return item;\n    });\n\n    // ordered list\n    isFirstListItem = false;\n    newArr = newArr.map( ( item, index, arr ) => {\n        if ( isOrderedList.test( item ) ) {\n            item = item.replace( isOrderedList, ( $0, $1, $2, $3, $4, index, str ) => {\n                return \"<li>\" + $4 + \"</li>\";\n            });\n            if ( !isFirstListItem ) {\n                item = olStart + item;\n            }\n            if ( !arr[index + 1] || !isOrderedList.test( arr[index + 1] ) ) {\n                item = item + olEnd;\n            }\n            isFirstListItem = true;\n        } else {\n            isFirstListItem = false;\n        }\n        return item;\n    });\n    content = newArr.join(\"\\n\");\n    return content;\n};\n\n\n// isUnorderedList = (^(\\t|(\\u0020){4})*)((:?[\\*|\\+|\\-])(:?\\u0020)+)(.*?)$\n//\n//\n//\n// * asdfasdfasdfa是\n// + asdfasdfasdfa2\n// - asdfasdfasdfa1\n//\n// 1. 23123\n// 2. 23123\n//     * asdfasdfasdfa是\n//     + asdfasdfasdfa2\n// \t\t1. 23123\n// \t\t3. 23123\n//     - asdfasdfasdfa1\n// 3. 23123\n//\n//\n// (^(\\t|(\\u0020){4})*)((:?[\\*\\+\\-])(:?\\u0020)+)(.*?)$ // 匹配无序列表，\n","/**\n * table\n * @return {[type]} [description]\n */\nexport default ( content ) => {\n    let a = [1,2,3];\n    return content;\n};\n","// ^```(.*|\\n)+?([^`]){3,}```$\n// ^```(.*|\\n)+?([^`]){3,}```$\n\n// /(^\\u0020*`{3}([a-zA-z]{3,10})?)(\\n.*?)+`{3}$/gm                   // code block with ``` ==> <pre><code> </code><pre>\n// /(\\u0020*`{3}[^`])(.*?)(`{3})/gm                                   // inline code with ```  ==> <code> <code>\n// /(\\u0020*`{2}[^`])(.*?)(`{2})/gm                                   // inline code with ``  ==> <code> <code>\n// /(\\u0020*`[^`])(.*?)(`)/gm                                         // inline code with  ` ==> <code> <code>\n\nexport default ( content ) => {\n    /** convert codeBlock */\n    let regCodeBlock = /(^(\\u0020)*`{3}(\\w|\\-|\\.|\\+|\\-{1,10})?)((\\n.*?)+)(`{3}$)/gm;\n    let isCode = /\\<code\\>(.*?)\\<\\/code\\>/;\n    let hasLineBreak = /\\r?\\n/;\n    content = content.replace( regCodeBlock, ( $0, $1, $2, $3, $4, $5, $6, index, str ) => {\n        let text = $4;\n        let lang = $3 ? $3.toLowerCase() : \"nohighlight\";               // language\n        text = \"<pre><code class='\" + lang + \"'>\" + text + \"</code></pre>\";\n        return text;\n    });\n    /** inline code with ``` .* ``` */\n    let arr = content.split( /\\n/ );\n    let newContent = arr.map( ( item, index ) => {\n        for ( let i = 3; i >= 1; i-- ) {\n            let inlineCode = `(\\`{${i}})([^\\`]{1,}.*?[^\\`]*)(\\`{${i}})`;\n            let regex = new RegExp( inlineCode, \"g\" );\n            item = item.replace( regex, ( $0, $1, $2, $3, index, str ) => {\n                let text = $2;\n                if ( !isCode.test( text ) && $2.length > 0 && !hasLineBreak.test( text ) ) {\n                    text = \"<code>\" + text + \"</code>\";\n                    return text;\n                } else {\n                    return $0;\n                }\n            });\n        }\n        return item;\n    });\n    return newContent.join( \"\\n\" );\n};\n","/**\n * paragraph\n * @param  {[type]} content [description]\n * @return {[type]}         [description]\n */\nexport default ( content ) => {\n    let arr = content.split( /\\n/ );\n    let isHTML = /^<[a-zA-Z0-9]{1,11}(\\s.{1,18})?>.*<\\/[a-zA-Z0-9]{1,11}>$/;      // no globally\n    let isSpace = /^\\u0020+|\\r|\\n$/;                                          // space & line break\n    let isCodeStart = /^(<pre>)?<code>$/;\n    let isCodeEnd = /^<\\/code>(<pre>)?/;\n    let status = false;\n    let newContent = arr.map( ( item, index, arr ) => {\n        // console.log(item);\n        let str = \"\";\n        // if ( isCodeStart.test( item ) || status ) {\n        //     status = true;\n        //     newContent += ( item + \"\\r\\n\" );\n        //     return;\n        // }\n        // if ( isCodeEnd.test( item ) ) {\n        //     status = false;\n        //     newContent += ( item + \"\\r\\n\" );\n        //     return;\n        // }\n        // item = item.replace( /\\s/g, \"\" );           // TODO: should keep space\n        if ( !isHTML.test( item ) && !isSpace.test( item ) && item !== \"\" ) {\n            str = `<p>${ item }</p>`;\n        } else {\n            str = item;\n        }\n        return str;\n    });\n    newContent = newContent.join( \"\\n\" );\n    return newContent;\n};\n","/**\n * Blockquotes (nested)\n * @param  {[type]} content [description]\n * @return {[type]}         [description]s\n */\nexport default ( content ) => {\n    let regex = /(^((\\u0020)*>+(\\u0020)*)+)(.*)([^>]$)/gm;         // (^>+(\\u0020)*)+(.*)([^>]$)\n    content = content.replace( regex, ( $0, $1, $2, $3, $4, $5, index, str ) => {\n        let blockquoteStart = \"<blockquotes>\";\n        let blockquoteEnd = \"</blockquotes>\";\n        let count = 0;\n        let reg = />/g;\n        while ( reg.test( $1 ) ) {\n            count++;\n        }\n        return `${blockquoteStart.repeat( count )}${$5}${blockquoteEnd.repeat( count )}`;\n    });\n    return content;\n};\n"],"names":["Ziz","content","escapeSpecialChars","header","link","table","code","list","blockquotes","del","paragraph","replace","reg","$0","$1","$2","setextHeader1","setextHeader2","i","atx","regex","RegExp","index","str","inlineLinkRegex","$3","$4","text","url","title","ulStart","ulEnd","olStart","olEnd","isUnorderedList","isOrderedList","arr","split","isFirstListItem","length","newArr","map","item","test","join","regCodeBlock","isCode","hasLineBreak","$5","$6","lang","toLowerCase","newContent","inlineCode","isHTML","isSpace","blockquoteStart","blockquoteEnd","count","repeat"],"mappings":"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"}